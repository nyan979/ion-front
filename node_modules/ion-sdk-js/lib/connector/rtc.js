"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RTC = exports.MediaType = exports.TrackState = void 0;
const grpc_web_1 = require("@improbable-eng/grpc-web");
const client_1 = require("../client");
const events_1 = require("events");
const sfu_rpc = require("../_library/proto/rtc/rtc_pb_service");
const pb = require("../_library/proto/rtc/rtc_pb");
/**
 * TrackState: track state
 */
var TrackState;
(function (TrackState) {
    TrackState[TrackState["ADD"] = 0] = "ADD";
    TrackState[TrackState["UPDATE"] = 1] = "UPDATE";
    TrackState[TrackState["REMOVE"] = 2] = "REMOVE";
})(TrackState = exports.TrackState || (exports.TrackState = {}));
/**
 * MediaType: media type
 */
var MediaType;
(function (MediaType) {
    MediaType[MediaType["MEDIAUNKNOWN"] = 0] = "MEDIAUNKNOWN";
    MediaType[MediaType["USERMEDIA"] = 1] = "USERMEDIA";
    MediaType[MediaType["SCREENCAPTURE"] = 2] = "SCREENCAPTURE";
    MediaType[MediaType["CAVANS"] = 3] = "CAVANS";
    MediaType[MediaType["STREAMING"] = 4] = "STREAMING";
    MediaType[MediaType["VOIP"] = 5] = "VOIP";
})(MediaType = exports.MediaType || (exports.MediaType = {}));
/**
 * RTC: rtc class
 */
class RTC {
    /**
     * constructor
     * @date 2021-11-03
     * @param {any} connector:Connector
     * @param {any} config?:Configuration
     * @returns
     */
    constructor(connector, config) {
        this.name = 'rtc';
        this.config = config;
        this.connected = false;
        this.connector = connector;
        this.connector.registerService(this);
        this.connect();
    }
    /**
     * join rtc session
     * @date 2021-11-03
     * @param {any} sid:string
     * @param {any} uid:string
     * @param {any} config:JoinConfig|undefined
     * @returns
     */
    async join(sid, uid, config) {
        var _a;
        this._sig.config = config;
        return (_a = this._rtc) === null || _a === void 0 ? void 0 : _a.join(sid, uid);
    }
    /**
     * leave session
     * @date 2021-11-03
     * @returns
     */
    leave() {
        var _a;
        return (_a = this._rtc) === null || _a === void 0 ? void 0 : _a.leave();
    }
    /**
     * get pub stats
     * @date 2021-11-03
     * @param {any} selector?:MediaStreamTrack
     * @returns {any}
     */
    getPubStats(selector) {
        var _a;
        return (_a = this._rtc) === null || _a === void 0 ? void 0 : _a.getPubStats(selector);
    }
    /**
     * get sub stats
     * @date 2021-11-03
     * @param {any} selector?:MediaStreamTrack
     * @returns {any}
     */
    getSubStats(selector) {
        var _a;
        return (_a = this._rtc) === null || _a === void 0 ? void 0 : _a.getSubStats(selector);
    }
    /**
     * publish local stream
     * @date 2021-11-03
     * @param {any} stream:LocalStream
     * @returns {any}
     */
    publish(stream) {
        var _a;
        this._sig.buildTrackInfos(stream);
        (_a = this._rtc) === null || _a === void 0 ? void 0 : _a.publish(stream);
    }
    /**
     * subscribe
     * @date 2021-11-03
     * @param {any} trackInfos:Subscription[]
     * @returns {any}
     */
    subscribe(trackInfos) {
        var _a;
        return (_a = this._sig) === null || _a === void 0 ? void 0 : _a.subscribe(trackInfos);
    }
    /**
     * createDataChannel
     * @date 2021-11-03
     * @param {any} label:string
     * @returns {any}
     */
    createDataChannel(label) {
        var _a;
        return (_a = this._rtc) === null || _a === void 0 ? void 0 : _a.createDataChannel(label);
    }
    /**
     * connect to signal
     * @date 2021-11-03
     * @returns {any}
     */
    connect() {
        if (!this._sig) {
            this._sig = new RTCGRPCSignal(this, this.connector);
        }
        if (!this._rtc) {
            this._rtc = new client_1.default(this._sig, this === null || this === void 0 ? void 0 : this.config);
            this._rtc.ontrack = (track, stream) => {
                var _a;
                // TODO: Attach track info to RemoteStream.
                (_a = this.ontrack) === null || _a === void 0 ? void 0 : _a.call(this, track, stream);
            };
            this._rtc.ondatachannel = (ev) => { var _a; return (_a = this.ondatachannel) === null || _a === void 0 ? void 0 : _a.call(this, ev); };
            this._rtc.onspeaker = (ev) => { var _a; return (_a = this.onspeaker) === null || _a === void 0 ? void 0 : _a.call(this, ev); };
            this._sig.ontrackevent = (ev) => {
                var _a;
                // TODO: Attach RemoteStream info to track event.
                (_a = this.ontrackevent) === null || _a === void 0 ? void 0 : _a.call(this, ev);
            };
        }
    }
    /**
     * close rtc
     * @date 2021-11-03
     * @returns {any}
     */
    close() {
        if (this._rtc) {
            this._rtc.close();
        }
    }
}
exports.RTC = RTC;
/**
 * RTCGRPCSignal: rtc grpc signal
 */
class RTCGRPCSignal {
    constructor(service, connector) {
        this._event = new events_1.EventEmitter();
        this.connector = connector;
        const client = grpc_web_1.grpc.client(sfu_rpc.RTC.Signal, this.connector.grpcClientRpcOptions());
        client.onEnd((status, statusMessage, trailers) => connector.onEnd(service, status, statusMessage, trailers));
        client.onHeaders((headers) => connector.onHeaders(service, headers));
        client.onMessage((reply) => {
            var _a;
            switch (reply.getPayloadCase()) {
                case pb.Reply.PayloadCase.JOIN:
                    const result = reply.getJoin();
                    this._event.emit('join-reply', result);
                    break;
                case pb.Reply.PayloadCase.DESCRIPTION:
                    const desc = reply.getDescription();
                    if ((desc === null || desc === void 0 ? void 0 : desc.getType()) === 'offer') {
                        if (this.onnegotiate)
                            this.onnegotiate({ sdp: desc.getSdp(), type: 'offer' });
                    }
                    else if ((desc === null || desc === void 0 ? void 0 : desc.getType()) === 'answer') {
                        this._event.emit('description', { sdp: desc.getSdp(), type: 'answer' });
                    }
                    if ((desc === null || desc === void 0 ? void 0 : desc.getTrackinfosList()) && (desc === null || desc === void 0 ? void 0 : desc.getTrackinfosList().length) > 0) {
                        // TODO: process metadata.
                    }
                    break;
                case pb.Reply.PayloadCase.TRICKLE:
                    const pbTrickle = reply.getTrickle();
                    if ((pbTrickle === null || pbTrickle === void 0 ? void 0 : pbTrickle.getInit()) !== undefined) {
                        const candidate = JSON.parse(pbTrickle.getInit());
                        const trickle = { target: pbTrickle.getTarget(), candidate };
                        if (this.ontrickle)
                            this.ontrickle(trickle);
                    }
                    break;
                case pb.Reply.PayloadCase.TRACKEVENT:
                    {
                        const evt = reply.getTrackevent();
                        let state = TrackState.ADD;
                        switch (evt === null || evt === void 0 ? void 0 : evt.getState()) {
                            case pb.TrackEvent.State.ADD:
                                state = TrackState.ADD;
                                break;
                            case pb.TrackEvent.State.UPDATE:
                                state = TrackState.UPDATE;
                                break;
                            case pb.TrackEvent.State.REMOVE:
                                state = TrackState.REMOVE;
                                break;
                        }
                        const tracks = Array();
                        const uid = (evt === null || evt === void 0 ? void 0 : evt.getUid()) || '';
                        evt === null || evt === void 0 ? void 0 : evt.getTracksList().forEach((rtcTrack) => {
                            tracks.push({
                                id: rtcTrack.getId(),
                                kind: rtcTrack.getKind(),
                                label: rtcTrack.getLabel(),
                                stream_id: rtcTrack.getStreamid(),
                                muted: rtcTrack.getMuted(),
                                type: rtcTrack.getType() || MediaType.MEDIAUNKNOWN,
                                layer: rtcTrack.getLayer(),
                                width: rtcTrack.getWidth() || 0,
                                height: rtcTrack.getHeight() || 0,
                                frame_rate: rtcTrack.getFramerate() || 0,
                            });
                        });
                        (_a = this.ontrackevent) === null || _a === void 0 ? void 0 : _a.call(this, { state, tracks, uid });
                    }
                    break;
                case pb.Reply.PayloadCase.SUBSCRIPTION:
                    const subscription = reply.getSubscription();
                    this._event.emit('subscription', {
                        success: (subscription === null || subscription === void 0 ? void 0 : subscription.getSuccess()) || false,
                        error: subscription === null || subscription === void 0 ? void 0 : subscription.getError(),
                    });
                case pb.Reply.PayloadCase.ERROR:
                    break;
            }
        });
        this._client = client;
        this._client.start(this.connector.metadata);
    }
    set config(config) {
        this._config = config;
    }
    /**
     * join a session
     * @date 2021-11-03
     * @param {any} sid:string
     * @param {any} uid:null|string
     * @param {any} offer:RTCSessionDescriptionInit
     * @returns {any}
     */
    join(sid, uid, offer) {
        var _a, _b, _c;
        const request = new pb.Request();
        const join = new pb.JoinRequest();
        join.setSid(sid);
        join.setUid(uid || '');
        if (this._config) {
            join.getConfigMap().set('NoPublish', ((_a = this._config) === null || _a === void 0 ? void 0 : _a.no_publish) ? 'true' : 'false');
            join.getConfigMap().set('NoSubscribe', ((_b = this._config) === null || _b === void 0 ? void 0 : _b.no_subscribe) ? 'true' : 'false');
            join.getConfigMap().set('NoAutoSubscribe', ((_c = this._config) === null || _c === void 0 ? void 0 : _c.no_auto_subscribe) ? 'true' : 'false');
        }
        const dest = new pb.SessionDescription();
        dest.setSdp(offer.sdp || '');
        dest.setType(offer.type || '');
        dest.setTarget(pb.Target.PUBLISHER);
        if (this._tracksInfos) {
            dest.setTrackinfosList(this._tracksInfos);
        }
        join.setDescription(dest);
        request.setJoin(join);
        this._client.send(request);
        return new Promise((resolve, reject) => {
            const handler = (result) => {
                var _a;
                if (result.getSuccess()) {
                    resolve({
                        sdp: result.getDescription().getSdp(),
                        type: result.getDescription().getType(),
                    });
                }
                else {
                    reject((_a = result.getError()) === null || _a === void 0 ? void 0 : _a.toObject());
                }
                this._event.removeListener('join-reply', handler);
            };
            this._event.addListener('join-reply', handler);
        });
    }
    /**
     * send trickle
     * @date 2021-11-03
     * @param {any} trickle:Trickle
     * @returns {any}
     */
    trickle(trickle) {
        const request = new pb.Request();
        const pbTrickle = new pb.Trickle();
        pbTrickle.setInit(JSON.stringify(trickle.candidate));
        request.setTrickle(pbTrickle);
        this._client.send(request);
    }
    /**
     * send offer request
     * @date 2021-11-03
     * @param {any} offer:RTCSessionDescriptionInit
     * @returns {any}
     */
    offer(offer) {
        const request = new pb.Request();
        const dest = new pb.SessionDescription();
        dest.setSdp(offer.sdp || '');
        dest.setType(offer.type || '');
        dest.setTarget(pb.Target.PUBLISHER);
        if (this._tracksInfos) {
            dest.setTrackinfosList(this._tracksInfos);
        }
        request.setDescription(dest);
        this._client.send(request);
        return new Promise((resolve, reject) => {
            const handler = (desc) => {
                resolve(desc);
                this._event.removeListener('description', handler);
            };
            this._event.addListener('description', handler);
        });
    }
    /**
     * send answer request
     * @date 2021-11-03
     * @param {any} answer:RTCSessionDescriptionInit
     * @returns {any}
     */
    answer(answer) {
        const request = new pb.Request();
        const desc = new pb.SessionDescription();
        desc.setSdp(answer.sdp || '');
        desc.setType(answer.type || '');
        desc.setTarget(pb.Target.SUBSCRIBER);
        request.setDescription(desc);
        this._client.send(request);
    }
    /**
     * close client
     * @date 2021-11-03
     * @returns {any}
     */
    close() {
        var _a;
        (_a = this._client) === null || _a === void 0 ? void 0 : _a.close();
    }
    /**
     * subscribe
     * @date 2021-11-03
     * @param {any} infos:Subscription[]
     * @returns {any}
     */
    subscribe(infos) {
        const request = new pb.Request();
        const subscription = new pb.SubscriptionRequest();
        const tracksInfos = Array();
        infos.forEach((t) => {
            const trackInfo = new pb.Subscription();
            trackInfo.setTrackid(t.track_id);
            trackInfo.setMute(t.muted);
            trackInfo.setLayer(t.layer);
            trackInfo.setSubscribe(t.subscribe);
            tracksInfos.push(trackInfo);
        });
        subscription.setSubscriptionsList(tracksInfos);
        request.setSubscription(subscription);
        this._client.send(request);
        return new Promise((resolve, reject) => {
            const handler = (res) => {
                resolve(res);
                this._event.removeListener('subscription', handler);
            };
            this._event.addListener('subscription', handler);
        });
    }
    /**
     * build TrackInfos
     * @date 2021-11-03
     * @param {any} stream:LocalStream
     * @returns {any}
     */
    buildTrackInfos(stream) {
        const tracks = stream.getTracks();
        const trackInfos = new Array();
        for (const track of tracks) {
            const trackInfo = new pb.TrackInfo();
            trackInfo.setId(track.id);
            trackInfo.setKind(track.kind);
            trackInfo.setLabel(track.label);
            trackInfo.setStreamid(stream.id);
            trackInfo.setMuted(!track.enabled);
            trackInfo.setType(MediaType.USERMEDIA);
            trackInfos.push(trackInfo);
        }
        this._tracksInfos = trackInfos;
    }
}
